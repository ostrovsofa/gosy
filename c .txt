/// Пишем все в одном файле 

#include "TicketExample.h"// Возможно эту строку нужно будет удалить что бы работало
#include <string>
#include <iostream>
using namespace std;

/// <summary>
/// Кароче, ебать структура с данными по билету
/// </summary>
struct RegistrationForm
{
	int Number;
	string Surname;
	string Name;
	string Partonimyc;
};
//Это наша Нода, ебать, узел, если ты русский
struct NodeTwoExample :RegistrationForm
{
	//Это значение ноды
	RegistrationForm val;
	//Указатель на следующую ноду
	NodeTwoExample* next;
	//Указатель на предыдущую
	NodeTwoExample* previos;
	//Я в ахуе, но это конструктор, в который будут совать свои грязные данные н'вахи(другие структуры или кому там это надо)
	NodeTwoExample(RegistrationForm _val)  : val(_val), next(nullptr), previos(nullptr) {}
};
//Структура самого двусвязного списка
struct TwoListExample
{
	//Это у нас первый парень на вписке
	NodeTwoExample* first;
	//Это у нас последний парень на вписке
	NodeTwoExample* last;
	//Тоже конструктор, ага
	TwoListExample() : first(nullptr), last(nullptr) {}
	//Проверка на то, пустой ли список или нет
	bool is_empty() {
		return first == nullptr;
	}
	//печатаем чо у нас в списке
	void print() {
		//Если пусто, то ничего не печатаем
		if (is_empty()) return;
		//Ставим во главу пересчёта первого на вписке
		NodeTwoExample* p = first;
		//Циклим, выписываем, чо там было в стракте
		while (p) { // p != nullptr
			cout << "Number: " << p->val.Number << " ";
			cout << "Surname: " << p->val.Surname << " ";
			cout << "Name: " << p->val.Name << " ";
			cout << "Partonimyc: " << p->val.Partonimyc << endl;
			p = p->next;
		}
		cout << endl;
	}
	
	//А вот и вставочка в середину
	void insert_middle(RegistrationForm _val)
	{
		NodeTwoExample* p = new NodeTwoExample(_val);
		NodeTwoExample* pTemp = first;
		//Если пусто, то просто вставляем
		if (is_empty()) {
			first = p;
			last = p;
			p->previos = nullptr;
			p->next = nullptr;
			return;
		}
		while (p->val.Number > pTemp->val.Number)
		{
			if (pTemp->next == nullptr)
			{
				break;
			}
			pTemp=pTemp->next;
		}
		if (pTemp == first)
		{
			if (p->val.Number > pTemp->val.Number)
			{
				pTemp->next = p;
				p->previos = pTemp;
				return;
			}
			else
			{
				pTemp->previos = p;
				p->next = pTemp;
				first = p;
				return;
			}
			
		}
		else if(pTemp == last)
		{
			if (p->val.Number > pTemp->val.Number)
			{
				pTemp->next = p;
				p->previos = pTemp;
				last = p;
				return;
			}
			else
			{
				pTemp->previos = p;
				p->next = pTemp;
				return;
			}
		}
	}

};

int main()
{
	TwoListExample list;
	RegistrationForm test;
	test.Name = "Test1";
	test.Partonimyc = "Random";
	test.Surname = "Blya";
	test.Number = 4;
	list.insert_middle(test);
	test.Number = 2;
	list.insert_middle(test);
	test.Number = 8;
	list.insert_middle(test);
	test.Number = 12;
	list.insert_middle(test);
	test.Number = 1;
	list.insert_middle(test);
	list.print();
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <iostream>
using namespace std;

//структура данных в элементе
struct People
{
    int Number;
    string Surname;
    string Name;
    string Partonimyc;
};
//структура элемента
struct Elem
{

    People data;
    Elem* next, * prev;
};


class List
{
    // Голова, хвост
    Elem* Head, * Tail;
    // Количество элементов
    int Count;

public:

    // Конструктор
    List();
    // Конструктор копирования
    List(const List&);
    // Деструктор
    ~List();

    // Получить количество
    int GetCount();
    // Получить элемент списка
    Elem* GetElem(int);

    // Удалить весь список
    void DelAll();
    // Удаление элемента, если параметр не указывается,
    // то функция его запрашивает
    void Del(int pos = 0);
    // Вставка элемента, если параметр не указывается,
    // то функция его запрашивает
    void Insert(int pos = 0);
    // Вставка элемента в середину
    void InsertMiddle(People n);
    // Добавление в конец списка
    void AddTail(People n);

    // Добавление в начало списка
    void AddHead(People n);

    // Печать списка
    void Print();
    // Печать определенного элемента
    void Print(int pos);
};

List::List()
{
    // Изначально список пуст
    Head = Tail = NULL;
    Count = 0;
}

List::List(const List& L)
{
    Head = Tail = NULL;
    Count = 0;

    // Голова списка, из которого копируем
    Elem* temp = L.Head;
    // Пока не конец списка
    while (temp != 0)
    {
        // Передираем данные
        AddTail(temp->data);
        temp = temp->next;
    }
}

List::~List()
{
    // Удаляем все элементы
    DelAll();
}

void List::AddHead(People n)
{
    // новый элемент
    Elem* temp = new Elem;

    // Предыдущего нет
    temp->prev = 0;
    // Заполняем данные
    temp->data = n;
    // Следующий - бывшая голова
    temp->next = Head;

    // Если элементы есть?
    if (Head != 0)
        Head->prev = temp;

    // Если элемент первый, то он одновременно и голова и хвост
    if (Count == 0)
        Head = Tail = temp;
    else
        // иначе новый элемент - головной
        Head = temp;

    Count++;
}

void List::AddTail(People n)
{
    // Создаем новый элемент
    Elem* temp = new Elem;
    // Следующего нет
    temp->next = 0;
    // Заполняем данные
    temp->data = n;
    // Предыдущий - бывший хвост
    temp->prev = Tail;

    // Если элементы есть?
    if (Tail != 0)
        Tail->next = temp;

    // Если элемент первый, то он одновременно и голова и хвост
    if (Count == 0)
        Head = Tail = temp;
    else
        // иначе новый элемент - хвостовой
        Tail = temp;

    Count++;
}

void List::Insert(int pos)
{
    // если параметр отсутствует или равен 0, то запрашиваем его
    if (pos == 0)
    {
        cout << "Input position: ";
        cin >> pos;
    }

    // Позиция от 1 до Count?
    if (pos < 1 || pos > Count + 1)
    {
        // Неверная позиция
        cout << "Incorrect position !!!\n";
        return;
    }

    // Если вставка в конец списка
    if (pos == Count + 1)
    {
        // Вставляемые данные
        People form;
        cout << "Input new number: ";
        cin >> form.Number;
        cout << "Input new Surname: ";
        cin >> form.Surname;
        cout << "Input new Name: ";
        cin >> form.Name;
        cout << "Input new Partonimyc: ";
        cin >> form.Partonimyc;
        // Добавление в конец списка
        AddTail(form);
        return;
    }
    else if (pos == 1)
    {
        // Вставляемые данные
        People form;
        cout << "Input new number: ";
        cin >> form.Number;
        cout << "Input new Surname: ";
        cin >> form.Surname;
        cout << "Input new Name: ";
        cin >> form.Name;
        cout << "Input new Partonimyc: ";
        cin >> form.Partonimyc;
        // Добавление в начало списка
        AddHead(form);
        return;
    }

    // Счетчик
    int i = 1;

    // Отсчитываем от головы n - 1 элементов
    Elem* Ins = Head;

    while (i < pos)
    {
        // Доходим до элемента, 
        // перед которым вставляемся
        Ins = Ins->next;
        i++;
    }

    // Доходим до элемента, 
    // который предшествует
    Elem* PrevIns = Ins->prev;

    // Создаем новый элемент
    Elem* temp = new Elem;

    // Вводим данные
    People form;
    cout << "Input new number: ";
    cin >> form.Number;
    cout << "Input new Surname: ";
    cin >> form.Surname;
    cout << "Input new Name: ";
    cin >> form.Name;
    cout << "Input new Partonimyc: ";
    cin >> form.Partonimyc;
    temp->data = form;

    // настройка связей
    if (PrevIns != 0 && Count != 1)
        PrevIns->next = temp;

    temp->next = Ins;
    temp->prev = PrevIns;
    Ins->prev = temp;

    Count++;
}

void List::Del(int pos)
{
    // если параметр отсутствует или равен 0, то запрашиваем его
    if (pos == 0)
    {
        cout << "Input position: ";
        cin >> pos;
    }
    // Позиция от 1 до Count?
    if (pos < 1 || pos > Count)
    {
        // Неверная позиция
        cout << "Incorrect position !!!\n";
        return;
    }

    // Счетчик
    int i = 1;

    Elem* Del = Head;

    while (i < pos)
    {
        // Доходим до элемента, 
        // который удаляется
        Del = Del->next;
        i++;
    }

    // Доходим до элемента, 
    // который предшествует удаляемому
    Elem* PrevDel = Del->prev;
    // Доходим до элемента, который следует за удаляемым
    Elem* AfterDel = Del->next;

    // Если удаляем не голову
    if (PrevDel != 0 && Count != 1)
        PrevDel->next = AfterDel;
    // Если удаляем не хвост
    if (AfterDel != 0 && Count != 1)
        AfterDel->prev = PrevDel;

    // Удаляются крайние?
    if (pos == 1)
        Head = AfterDel;
    if (pos == Count)
        Tail = PrevDel;

    // Удаление элемента
    delete Del;

    Count--;
}

void List::Print(int pos)
{
    // Позиция от 1 до Count?
    if (pos < 1 || pos > Count)
    {
        // Неверная позиция
        cout << "Incorrect position !!!\n";
        return;
    }

    Elem* temp;

    // Определяем с какой стороны 
    // быстрее двигаться
    if (pos <= Count / 2)
    {
        // Отсчет с головы
        temp = Head;
        int i = 1;

        while (i < pos)
        {
            // Двигаемся до нужного элемента
            temp = temp->next;
            i++;
        }
    }
    else
    {
        // Отсчет с хвоста
        temp = Tail;
        int i = 1;

        while (i <= Count - pos)
        {
            // Двигаемся до нужного элемента
            temp = temp->prev;
            i++;
        }
    }
    // Вывод элемента
    cout << pos << " element: ";
    cout << temp->data.Number << ", ";
    cout << temp->data.Surname << ", ";
    cout << temp->data.Name << ", ";
    cout << temp->data.Partonimyc << ", " << endl;
}

void List::Print()
{
    // Если в списке присутствуют элементы, то пробегаем по нему
    // и печатаем элементы, начиная с головного
    if (Count != 0)
    {
        Elem* temp = Head;
        while (temp!= 0)
        {
            cout << temp->data.Number << ", ";
            cout << temp->data.Surname << ", ";
            cout << temp->data.Name << ", ";
            cout << temp->data.Partonimyc;
            temp = temp->next;
            cout << "\n";
        }
    }
}
void List::InsertMiddle(People form)
{
    Elem* temp = new Elem;
    temp = Head;
    //Если пусто, то просто вставляем
    if (Count == 0)
    {
        AddTail(form);
        return;
    }
    //Узнаём, где середина
    int count = Count / 2;
    //Двигаемся в середину
    for (int i = 0; i < count; i++)
    {
        temp = temp->next;
    }
    //Создаём новый элемент
    Elem* tempNew = new Elem;
    // Предыдущий - бывший хвост
    tempNew->prev = temp->prev;
    //У старого предыдущий новый
    temp->prev->next = tempNew;
    //У нового следующий старый
    tempNew->next = temp;
    //У старого предыдущий это новый
    temp->prev = tempNew;
    //Добавляем данные
    tempNew->data = form;
}

void List::DelAll()
{
    // Пока остаются элементы, удаляем по одному с головы
    while (Count != 0)
        Del(1);
}

int List::GetCount()
{
    return Count;
}

Elem* List::GetElem(int pos)
{
    Elem* temp = Head;

    // Позиция от 1 до Count?
    if (pos < 1 || pos > Count)
    {
        // Неверная позиция
        cout << "Incorrect position !!!\n";
        return 0;
    }

    int i = 1;
    // Ищем нужный нам элемент
    while (i < pos && temp != 0)
    {
        temp = temp->next;
        i++;
    }

    if (temp == 0)
        return 0;
    else
        return temp;
}

// Тестовый пример
void main()
{
    setlocale(LC_ALL, "rus");
    List L;
    People form;
    form.Number = 123;
    form.Surname = "Эгов";
    form.Name = "Евгений";
    form.Partonimyc = "Николаевич";
    L.AddHead(form);
    form.Number = 1234;
    form.Surname = "Эгов4";
    form.Name = "Евгений4";
    form.Partonimyc = "Николаевич4";
    L.AddTail(form);
    form.Number = 1234;
    form.Surname = "Эгов4";
    form.Name = "Евгений4";
    form.Partonimyc = "Николаевич4";
    L.AddTail(form);
    // Распечатка списка
    cout << "List L:\n";
    L.Print();
    cout << endl;

    // Вставка элемента в список
    L.Insert();
    // Распечатка списка
    cout << "List L:\n";
    L.Print();
    // добавление в середину
    form.Number = 12345;
    form.Surname = "Эгов45";
    form.Name = "Евгений45";
    form.Partonimyc = "Николаевич45";
    cout << "Insert middle:\n";
    L.InsertMiddle(form);
    // Распечатка списка
    cout << "List L:\n";
    L.Print();
    // Распечатка 1-го элемента списка
    int n;
    cout << "Input element position: ";
    cin >> n;
    cout << "List L:\n";
    L.Print(n);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


#include <string>
#include <iostream>
using namespace std;


struct RegistrationForm
{
	int Number;
	string Surname;
	string Name;
	string Partonimyc;
};

struct Node : RegistrationForm
{
	//Это значение ноды
	RegistrationForm data;
	//Указатель на следующую ноду
	Node* prev;
	Node* next;
	
};

struct Node* getNode(RegistrationForm data)
{
	// allocate node
	Node* newNode = new Node();

	// put in the data
	newNode->data = data;
	newNode->prev = newNode->next = nullptr;
	return newNode;
}

void sortedInsert(struct Node** head_ref, struct Node* newNode)
{
	struct Node* current;

	// if list is empty
	if (*head_ref == nullptr)
		*head_ref = newNode;

	// beginning of the list
	else if ((*head_ref)->data.Number >= newNode->data.Number) {
		newNode->next = *head_ref;
		newNode->next->prev = newNode;
		*head_ref = newNode;
	}

	else {
		current = *head_ref;

		// locate the node after which the new node
		// is to be inserted
		while (current->next != nullptr &&
			current->next->data.Number < newNode->data.Number)
			current = current->next;

		/* Make the appropriate links */
		newNode->next = current->next;

		// if the new node is not inserted
		// at the end of the list
		if (current->next != nullptr)
			newNode->next->prev = newNode;

		current->next = newNode;
		newNode->prev = current;
	}
}
void printList(struct Node* head)
{
	while (head != nullptr) {
		cout << head->data.Number << " ";
		cout << head->data.Name << " ";
		cout << head->data.Surname << " \n";
		head = head->next;
	}
}

int main()
{
	struct Node* head = nullptr;
	RegistrationForm test;
	test.Name = "Test1";
	test.Partonimyc = "Random";
	test.Surname = "Bla";
	test.Number = 4;
	struct Node* new_node = getNode(test);
	new_node = getNode(test);
	sortedInsert(&head, new_node);
	test.Number = 8;
	new_node = getNode(test);
	sortedInsert(&head, new_node);
	test.Number = 12;
	new_node = getNode(test);
	sortedInsert(&head, new_node);
	test.Number = 1;
	new_node = getNode(test);
	sortedInsert(&head, new_node);
	printList(head);
	return 0;
}
